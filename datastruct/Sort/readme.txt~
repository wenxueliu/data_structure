内排序：
   插入排序：
      理解要点：
            1)有n-1趟。每趟比较之前，前面的都已经排好序。
            2)遇到比它大的就终止，因为前面的都比它小。(升序)
      插入排序为O(n2);最好情况是O(n),平均情况O(n2).交换次数是逆序数。
   冒泡排序：
           理解要点：
                n-1趟，每趟比较之前，前面的都已经排好序。
                每趟的元素与之前的元素比较，如果小就交换。
   选择排序：只交换一次，对于交换数据大的有优势。另外一种减少交换次数的是建立数组指针。
   
   

定理：N个互异的数组的平均逆序数是N(N-1)/4.
定理：通过交换相邻元素进行排序的任何算法平均需要时间N2时间。
  

    Shell排序：缩小增量排序。在中等规模的排序中shell很有竞争力。
            分析：最坏情况是O(n2);
                 使用Hibbard增量的希尔排序最坏的情况是O(n1.5)(Hibbard的增量是2K－1)；  
         O(n1.5)
    归并排序：
              算法复杂度：O(NlogN)  
             三种方法：递归(用辅助数组)、递归(不用辅助数组)、非递归。
             缺点：很难用于主存的排序，主要问题在于合并两个排序表需要线性的附加内存。
    快速排序：
             算法复杂度：最好和平均都是O(NlogN),最坏O(N2)
             选取枢纽元(pivot)：1、首元素。这是一种糟糕的选择方法。
                               2、随机生成。这个不错，但是生成的代价很昂贵。
                               3、中值分割法。较少了快速排序大约5%的时间。
             对于相同元素的考虑：对此的讨论可以避免最糟糕的选择方法。
       
             
             注：1、对于小的数组，快速排序不如插入排序好。而且，快速排序是递归的，在小数组的部分用插入排序，
            可以减少递归的层次。这样的策略可以减少15％的时间。
                 2、事实上，如果快排不是每次都是最糟糕的情况，那么它的O(NlogN),哪怕只有一次不是最坏的，都是O(NlogN)。
外排序：
