关于递归和非递归：
     对而二叉树的遍历操作一般都是通过遍历来实现的（不递归的方式是用栈来模拟
的，但速度比较慢），同时占用了很多空间。也即非递归算法无论是时间复杂度还是空间复杂度都比递归要高。非递归唯一的好处是节省了堆栈。
    文档在二叉树的插入、删除、最大值、最小值的函数中都采用了递归和非递归
 的实现
   

父节点：在非递归遍历的时候用到，在其他操作时都没有用到。(BSTree.h)


二叉树操作中要考虑的因素：
     1、树不能为空。
     2、删除操作中：
              删除的节点是根节点。
              1）被删节点左右叶子都不存在
              2）被删节点只有一个叶子节点存在
              3）被删节点两个叶子节点都存在
	          1)当两个叶子节点只有一个节点的时候
		  2)当两个叶子节点有两个或以上的节点的时候
        注：当二叉树没有重复出现时，没有问题；当有相同大小的叶子节点时，到底将左
子树的最大值还是右子树的最小值替换根节点呢？其实完全取决于定义。一般习惯将右子
树的最小值替换根节点。
            如果删除的次数不多，则使用的策略是懒惰删除，当一个元素被删除的时候，
	它仍然留在树中，只做个被删的记号。这种做法特别是在重复关键字时，很流行
	。因为此时记录出现频率的域可以减1(不懂？？),另外，删除和重新分配的开销
	都会小一些。
     3、插入操作
              考虑数据大小相同叶子节点。



在利用指针实现二叉树的时候，叶子结点和分支节点是否使用相同的节点十分重要：
   1)一些应用只需要用叶子节点来存储数据。
   2)一些应用需要叶子和分支分别存储不同结构的数据。表达式树、huffman树
   3)根据定义分支节点没有空子节点。所以可以节省空间。
  为了分别定义叶子和分支节点的数据类型。有三种方法：
    1)联合结构体
    2)类的继承。基类定义虚函数、两个子类继承。
    3)虚基类和两个独立的节点类
